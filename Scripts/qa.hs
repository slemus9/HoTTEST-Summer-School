{-# LANGUAGE DeriveGeneric, OverloadedStrings #-}

import Prelude

import Data.Csv
import Data.List
import qualified Data.Text as T (Text)
import qualified Data.Vector as V
import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString.Char8 as B8

import GHC.Generics
import System.IO
import Control.Monad

{- 0. Remove the top 6 lines over the Zoom csv, so that it starts with the first csv entry
   1. Go through the CSV generated by Zoom and replace any double quotes (") inside a question or answer by a single quote.
   2. Build this file [ghc qa], and run it: [./qa < zoom.csv > qa.txt]
   3. Search and Replace (non-exhaustive):
     1. \8220 -> `` (begin quote)
     2. \8221 -> '' (unquote) 
     3. \8217 -> ' (single quote)
     4. \8230 -> ... (three dots)
     5. \8212 -> --- (em dash)
     6. \8216 -> ` (left single quote)
     7. \8226 -> * (bullet)
     8. \931 -> \Sigma (Sigma)
     9. \\" -> " (double quotes)
   5. look for \\\\ and tex
   6. get things to build and fix any errors
-}

  
data CSV = CSV {
  question_id :: Int,
  csv_question :: T.Text,
  asker :: T.Text,
  asker_email :: T.Text,
  answer :: T.Text,
  question_time :: T.Text,
  answer_time :: T.Text,
  null :: T.Text -- QA.csv ends with a comma, for some reason...
} deriving (Generic, Show)


instance FromRecord CSV
instance ToRecord CSV

data QA = QA {
  qid :: Int,
  question :: T.Text,
  answers :: [T.Text]
}

showAnswers :: [T.Text] -> String
showAnswers [] = ""
showAnswers (a : as) = "  \\begin{answerbox}\n    " ++ show a ++ "\n  \\end{answerbox}\n"
                       ++ showAnswers as

instance Show QA where
  show (QA qid q as) = "\\section*{Q" ++ show qid ++ " " ++ show q ++ "}\n" ++ showAnswers as

format :: [CSV] -> [QA]
format = foldr op []
  where op (CSV qid q _ _ a _ _ _) []  = [QA qid q [a]]
        op (CSV qid q _ _ a _ _ _) (qa@(QA qid' q' as) : qas)
          | qid == qid' = (QA qid' q' (a : as) : qas)
          | otherwise   = (QA qid q [a] : qa : qas)

main = do
  {- At least in the CSV for the second HoTT lecture, there are three invisible characters before the "1" signifying the first entry, so we drop them. -}
  raw <- BL.drop 3 <$> BL.getContents

  case (format <$> V.toList <$> (decode NoHeader raw :: Either String (V.Vector CSV))) of
    Left err -> putStrLn err
    Right qas -> forM_ qas (putStrLn . show)
